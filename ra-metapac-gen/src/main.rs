use std::collections::BTreeMap;
use std::fs::{self, File};
use std::io::Write as _;
use std::fmt::Write as _;
use std::path::Path;
use std::process::Command;
use anyhow::Context;
use ra_data_types::Chip;

mod registers;

const AUTOGENERATED_TEXT: &str =
    "// This file is autogenerated by ra-metapac-gen: do not edit by hand.";

fn main() -> anyhow::Result<()> {
    let chips_dir = Path::new("build/data/chips/");
    let out_dir = Path::new("build/ra-metapac");
    fs::create_dir_all(out_dir.join("src")).context("failed to create output directory")?;

    // Copy static files
    fs::copy("ra-metapac-gen/res/build.rs", out_dir.join("build.rs"))?;
    fs::copy("ra-metapac-gen/res/lib.rs", out_dir.join("src/lib.rs"))?;
    fs::copy("ra-metapac-gen/res/metadata.rs", out_dir.join("src/metadata.rs"))?;

    let mut cargo_toml = fs::read_to_string("ra-metapac-gen/res/Cargo.toml")?;
    cargo_toml.insert_str(0, "[workspace]\n\n");

    // Must generate registers before the PAC to ensure that rustfmt can resolve imports.
    let block_map = registers::generate(out_dir)?;

    let chips_src_dir = out_dir.join("src/chips");
    fs::create_dir_all(&chips_src_dir).context("failed to create chips directory")?;

    let mut chip_features = String::new();
    let mut flavors: BTreeMap<String, &str> = BTreeMap::new();

    for entry in fs::read_dir(chips_dir).context(format!("failed to read chips directory: {:?}", chips_dir))? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |ext| ext == "json") {
            let content = fs::read_to_string(&path)?;
            let chip: Chip = serde_json::from_str(&content)?;
            
            let chip_name_lower = chip.name.to_lowercase();
            let chip_dir = chips_src_dir.join(&chip_name_lower);
            fs::create_dir_all(&chip_dir)?;

            generate_chip_pac(&chip, &chip_dir, &block_map)?;
            
            writeln!(chip_features, "{} = []", chip_name_lower)?;

            let target = match chip.core.as_str() {
                "Cortex-M23" => "thumbv6m-none-eabi",
                "Cortex-M33" => "thumbv8m.main-none-eabihf",
                "Cortex-M4" => "thumbv7em-none-eabi",
                "Cortex-M85" => "thumbv8m.main-none-eabihf",
                _ => "thumbv7m-none-eabi", // Default
            };

            let prefix = chip_name_lower[..7].to_string();
            flavors.insert(prefix, target);
        }
    }

    writeln!(cargo_toml, "\n[features]")?;
    writeln!(cargo_toml, "default = [\"pac\"]")?;
    writeln!(cargo_toml, "pac = []")?;
    writeln!(cargo_toml, "metadata = []")?;
    writeln!(cargo_toml, "rt = [\"cortex-m-rt/device\"]")?;
    writeln!(cargo_toml, "defmt = [\"dep:defmt\"]")?;
    writeln!(cargo_toml, "embassy = [\"dep:embassy-hal-internal\", \"embassy-hal-internal/cortex-m\", \"embassy-hal-internal/prio-bits-3\"]")?;
    cargo_toml.push_str(&chip_features);

    writeln!(cargo_toml, "\n[package.metadata.embassy_docs]")?;
    writeln!(cargo_toml, "features = [\"pac\", \"metadata\"]")?;
    writeln!(cargo_toml, "flavors = [")?;
    for (prefix, target) in flavors {
        writeln!(cargo_toml, "    {{ regex_feature = \"{}.*\", target = \"{}\" }},", prefix, target)?;
    }
    writeln!(cargo_toml, "]")?;

    fs::write(out_dir.join("Cargo.toml"), cargo_toml)?;

    Ok(())
}

fn generate_chip_pac(chip: &Chip, chip_dir: &Path, block_map: &BTreeMap<String, String>) -> anyhow::Result<()> {
    let interrupt_count = chip.interrupt_count as usize;

    // Generate pac.rs
    let pac_path = chip_dir.join("pac.rs");
    let mut file = File::create(&pac_path)?;

    writeln!(file, "{}", AUTOGENERATED_TEXT)?;
    
    writeln!(file, "pub mod peripherals {{")?;
    for (i, peri) in chip.peripherals.iter().enumerate() {
        let mod_name = format!("{}_{}", peri.peri_type.to_lowercase(), peri.version.to_lowercase());
        let block_name = block_map.get(&mod_name).cloned().unwrap_or_else(|| heck::AsPascalCase(&peri.peri_type).to_string());
        writeln!(file, "    #[derive(Copy, Clone)]")?;
        writeln!(file, "    pub struct {}(());", peri.name)?;
        writeln!(file, "    #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "    impl embassy_hal_internal::PeripheralType for {} {{}}", peri.name)?;
        writeln!(file, "    impl {} {{", peri.name)?;
        writeln!(file, "        pub const REGS: crate::_peripherals::{}::{} = unsafe {{ crate::_peripherals::{}::{}::from_ptr(0x{:08x} as *mut ()) }};", mod_name, block_name, mod_name, block_name, peri.address)?;
        writeln!(file, "        pub unsafe fn steal() -> Self {{")?;
        writeln!(file, "            Self(())")?;
        writeln!(file, "        }}")?;
        writeln!(file, "    }}")?;
        writeln!(file, "    impl core::ops::Deref for {} {{", peri.name)?;
        writeln!(file, "        type Target = crate::_peripherals::{}::{};", mod_name, block_name)?;
        writeln!(file, "        fn deref(&self) -> &Self::Target {{")?;
        writeln!(file, "            &Self::REGS")?;
        writeln!(file, "        }}")?;
        writeln!(file, "    }}")?;
        writeln!(file, "    #[cfg(feature = \"metadata\")]")?;
        writeln!(file, "    impl crate::Peripheral for {} {{", peri.name)?;
        writeln!(file, "        fn metadata() -> &'static crate::metadata::Peripheral {{")?;
        writeln!(file, "            &crate::metadata::PERIPHERALS[{}]", i)?;
        writeln!(file, "        }}")?;
        writeln!(file, "    }}")?;
    }

    let mut pins = std::collections::BTreeSet::new();
    for pkg in &chip.packages {
        for pin in &pkg.pins {
            for signal in &pin.signals {
                if signal.starts_with('p') && signal.len() >= 4 && signal[1..].chars().all(|c| c.is_ascii_digit()) {
                    pins.insert(signal.to_ascii_uppercase());
                }
            }
        }
    }

    writeln!(file, "    pub struct Peripherals {{")?;
    for peri in &chip.peripherals {
        writeln!(file, "        #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "        pub {}: embassy_hal_internal::Peri<'static, {}>,", peri.name.to_lowercase(), peri.name)?;
        writeln!(file, "        #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "        pub {}: {},", peri.name.to_lowercase(), peri.name)?;
    }
    for i in 0..interrupt_count {
        writeln!(file, "        #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "        pub iel{}: embassy_hal_internal::Peri<'static, IEL{}>,", i, i)?;
        writeln!(file, "        #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "        pub iel{}: IEL{},", i, i)?;
    }
    for pin in &pins {
        writeln!(file, "        #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "        pub {}: embassy_hal_internal::Peri<'static, {}>,", pin.to_lowercase(), pin)?;
        writeln!(file, "        #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "        pub {}: {},", pin.to_lowercase(), pin)?;
    }
    writeln!(file, "    }}")?;
    writeln!(file, "    impl Peripherals {{")?;
    writeln!(file, "        pub unsafe fn steal() -> Self {{")?;
    writeln!(file, "            Self {{")?;
    for peri in &chip.peripherals {
        writeln!(file, "                #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "                {}: embassy_hal_internal::Peri::new_unchecked({}(())),", peri.name.to_lowercase(), peri.name)?;
        writeln!(file, "                #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "                {}: {}(()),", peri.name.to_lowercase(), peri.name)?;
    }
    for i in 0..interrupt_count {
        writeln!(file, "                #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "                iel{}: embassy_hal_internal::Peri::new_unchecked(IEL{}(())),", i, i)?;
        writeln!(file, "                #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "                iel{}: IEL{}(()),", i, i)?;
    }
    for pin in &pins {
        writeln!(file, "                #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "                {}: embassy_hal_internal::Peri::new_unchecked({}(())),", pin.to_lowercase(), pin)?;
        writeln!(file, "                #[cfg(not(feature = \"embassy\"))]")?;
        writeln!(file, "                {}: {}(()),", pin.to_lowercase(), pin)?;
    }
    writeln!(file, "            }}")?;
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    for i in 0..interrupt_count {
        writeln!(file, "    #[derive(Copy, Clone)]")?;
        writeln!(file, "    pub struct IEL{}(());", i)?;
        writeln!(file, "    #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "    impl embassy_hal_internal::PeripheralType for IEL{} {{}}", i)?;
    }
    for pin in &pins {
        writeln!(file, "    #[derive(Copy, Clone)]")?;
        writeln!(file, "    pub struct {}(());", pin)?;
        writeln!(file, "    #[cfg(feature = \"embassy\")]")?;
        writeln!(file, "    impl embassy_hal_internal::PeripheralType for {} {{}}", pin)?;
    }
    writeln!(file, "}}")?;

    writeln!(file, "#[macro_export]")?;
    writeln!(file, "macro_rules! foreach_interrupt {{")?;
    writeln!(file, "    ($m:path, $($args:tt)*) => {{")?;
    writeln!(file, "        $m! {{ $($args)* {{")?;
    for i in 0..interrupt_count {
        writeln!(file, "            IEL{} = {},", i, i)?;
    }
    writeln!(file, "        }} }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "    ($($m:tt)*) => {{")?;
    writeln!(file, "        $($m)*! {{")?;
    for i in 0..interrupt_count {
        writeln!(file, "            IEL{} = {},", i, i)?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[macro_export]")?;
    writeln!(file, "macro_rules! foreach_event {{")?;
    writeln!(file, "    ($m:path, $($args:tt)*) => {{")?;
    writeln!(file, "        $m! {{ $($args)* {{")?;
    for irq in &chip.interrupts {
        let name = heck::AsPascalCase(&irq.name).to_string();
        let irq_nums = match &irq.irq_number {
            Some(nums) => format!("({})", nums.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(", ")),
            None => "()".to_string(),
        };
        writeln!(file, "            ({}, {}, {}),", name, irq.value, irq_nums)?;
    }
    writeln!(file, "        }} }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "    ($($m:tt)*) => {{")?;
    writeln!(file, "        $($m)*! {{")?;
    for irq in &chip.interrupts {
        let name = heck::AsPascalCase(&irq.name).to_string();
        let irq_nums = match &irq.irq_number {
            Some(nums) => format!("({})", nums.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(", ")),
            None => "()".to_string(),
        };
        writeln!(file, "            ({}, {}, {}),", name, irq.value, irq_nums)?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[macro_export]")?;
    writeln!(file, "macro_rules! foreach_peripheral {{")?;
    writeln!(file, "    ($m:path) => {{")?;
    writeln!(file, "        $m! {{")?;
    for (i, peri) in chip.peripherals.iter().enumerate() {
        writeln!(file, "            {} = {},", peri.name, i)?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[macro_export]")?;
    writeln!(file, "macro_rules! foreach_pin {{")?;
    writeln!(file, "    ($m:path) => {{")?;
    writeln!(file, "        $m! {{")?;
    for pin in &pins {
        let port = pin[1..2].parse::<u8>().unwrap_or(0);
        let pin_num = pin[2..].parse::<u8>().unwrap_or(0);
        writeln!(file, "            ({}, {}, {}),", pin, port, pin_num)?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }};")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[derive(Copy, Clone, Debug, PartialEq, Eq)]")?;
    writeln!(file, "#[repr(u16)]")?;
    writeln!(file, "pub enum Event {{")?;
    let mut seen_values = std::collections::HashSet::new();
    let mut aliases = Vec::new();
    for irq in &chip.interrupts {
        let name = heck::AsPascalCase(&irq.name).to_string();
        if seen_values.contains(&irq.value) {
            aliases.push((name, irq.value, irq.description.clone()));
            continue;
        }
        seen_values.insert(irq.value);
        if let Some(desc) = &irq.description {
            writeln!(file, "    /// {}", desc)?;
        }
        writeln!(file, "    {} = {},", name, irq.value)?;
    }
    writeln!(file, "}}")?;

    if !aliases.is_empty() {
        writeln!(file, "#[allow(non_upper_case_globals)]")?;
        writeln!(file, "impl Event {{")?;
        for (name, value, desc) in aliases {
            if let Some(d) = desc {
                writeln!(file, "    /// {}", d)?;
            }
            // Find the original name for this value to point the alias to it
            let original_irq = chip.interrupts.iter().find(|i| i.value == value).unwrap();
            let original_name = heck::AsPascalCase(&original_irq.name).to_string();
            writeln!(file, "    pub const {}: Self = Self::{};", name, original_name)?;
        }
        writeln!(file, "}}")?;
    }

    writeln!(file, "#[derive(Copy, Clone, Debug, PartialEq, Eq)]")?;
    writeln!(file, "#[repr(u16)]")?;
    writeln!(file, "pub enum Interrupt {{")?;
    for i in 0..interrupt_count {
        writeln!(file, "    IEL{} = {},", i, i)?;
    }
    writeln!(file, "}}")?;

    writeln!(file, "unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {{")?;
    writeln!(file, "    #[inline(always)]")?;
    writeln!(file, "    fn number(self) -> u16 {{")?;
    writeln!(file, "        self as u16")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[cfg(feature = \"embassy\")]")?;
    writeln!(file, "embassy_hal_internal::interrupt_mod!(")?;
    for i in 0..interrupt_count {
        writeln!(file, "    IEL{},", i)?;
    }
    writeln!(file, ");")?;

    writeln!(file, "extern \"C\" {{")?;
    for i in 0..interrupt_count {
        writeln!(file, "    pub fn IEL{}();", i)?;
    }
    writeln!(file, "}}")?;

    writeln!(file, "#[derive(Copy, Clone)]")?;
    writeln!(file, "#[repr(C)]")?;
    writeln!(file, "pub union Vector {{")?;
    writeln!(file, "    pub _handler: unsafe extern \"C\" fn(),")?;
    writeln!(file, "    pub _reserved: u32,")?;
    writeln!(file, "}}")?;

    writeln!(file, "#[link_section = \".vector_table.interrupts\"]")?;
    writeln!(file, "#[no_mangle]")?;
    writeln!(file, "pub static __INTERRUPTS: [Vector; {}] = [", interrupt_count)?;
    for i in 0..interrupt_count {
        writeln!(file, "    Vector {{ _handler: IEL{} }},", i)?;
    }
    writeln!(file, "];")?;

    rustfmt(pac_path);

    // Generate device.x
    let device_x_path = chip_dir.join("device.x");
    let mut device_x = File::create(&device_x_path)?;
    writeln!(device_x, "PROVIDE(NonMaskableInt = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(HardFault = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(MemoryManagement = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(BusFault = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(UsageFault = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(SecureFault = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(SVCall = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(DebugMonitor = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(PendSV = DefaultHandler);")?;
    writeln!(device_x, "PROVIDE(SysTick = DefaultHandler);")?;
    for i in 0..interrupt_count {
        writeln!(device_x, "EXTERN(IEL{});", i)?;
        writeln!(device_x, "PROVIDE(IEL{} = DefaultHandler);", i)?;
    }

    // Generate metadata.rs
    let metadata_path = chip_dir.join("metadata.rs");
    let mut file = File::create(&metadata_path)?;
    writeln!(file, "{}", AUTOGENERATED_TEXT)?;
    writeln!(file, "pub const NAME: &str = \"{}\";", chip.name)?;
    writeln!(file, "pub const FAMILY: &str = \"{}\";", chip.family)?;
    writeln!(file, "pub const CORE: &str = \"{}\";", chip.core)?;
    writeln!(file, "pub const INTERRUPT_COUNT: usize = {};", interrupt_count)?;

    writeln!(file, "pub const MEMORY: &[MemoryRegion] = &[")?;
    for mem in &chip.memory {
        writeln!(file, "    MemoryRegion {{")?;
        writeln!(file, "        name: \"{}\",", mem.name)?;
        writeln!(file, "        kind: \"{}\",", mem.kind)?;
        writeln!(file, "        address: {},", mem.address)?;
        writeln!(file, "        size: {},", mem.size)?;
        writeln!(file, "    }},")?;
    }
    writeln!(file, "];")?;

    writeln!(file, "pub const PERIPHERALS: &[Peripheral] = &[")?;
    for peri in &chip.peripherals {
        writeln!(file, "    Peripheral {{")?;
        writeln!(file, "        name: \"{}\",", peri.name)?;
        writeln!(file, "        address: {},", peri.address)?;
        writeln!(file, "        kind: \"{}\",", peri.peri_type)?;
        writeln!(file, "        version: \"{}\",", peri.version)?;
        if let Some(mstp) = &peri.mstp {
            writeln!(file, "        mstp: Some(Mstp {{")?;
            writeln!(file, "            register: \"{}\",", mstp.register)?;
            writeln!(file, "            bit: {},", mstp.bit)?;
            writeln!(file, "        }}),")?;
        } else {
            writeln!(file, "        mstp: None,")?;
        }
        if let Some(bw) = peri.bit_width {
            writeln!(file, "        bit_width: Some({}),", bw)?;
        } else {
            writeln!(file, "        bit_width: None,")?;
        }
        writeln!(file, "    }},")?;
    }
    writeln!(file, "];")?;

    // Generate EVENTS metadata
    writeln!(file, "pub const EVENTS: &[Event] = &[")?;
    for irq in &chip.interrupts {
        let name = heck::AsSnakeCase(&irq.name).to_string().to_uppercase();
        let irq_slots = match &irq.irq_number {
            Some(nums) => format!("&[{}]", nums.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(", ")),
            None => "&[]".to_string(),
        };
        writeln!(file, "    Event {{")?;
        writeln!(file, "        name: \"{}\",", name)?;
        writeln!(file, "        id: {},", irq.value)?;
        writeln!(file, "        irq_slots: {},", irq_slots)?;
        writeln!(file, "    }},")?;
    }
    writeln!(file, "];")?;

    writeln!(file, "pub const PACKAGES: &[Package] = &[")?;
    for pkg in &chip.packages {
        writeln!(file, "    Package {{")?;
        writeln!(file, "        name: \"{}\",", pkg.package)?;
        writeln!(file, "        pins: &[")?;
        for pin in &pkg.pins {
            writeln!(file, "            Pin {{")?;
            writeln!(file, "                position: \"{}\",", pin.position)?;
            writeln!(file, "                signals: &[")?;
            for sig in &pin.signals {
                writeln!(file, "                    \"{}\",", sig)?;
            }
            writeln!(file, "                ],")?;
            writeln!(file, "            }},")?;
        }
        writeln!(file, "        ],")?;
        writeln!(file, "    }},")?;
    }
    writeln!(file, "];")?;

    rustfmt(metadata_path);

    Ok(())
}

fn rustfmt<P: AsRef<Path>>(path: P) {
    Command::new("rustfmt")
        .arg(path.as_ref())
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}
