use std::collections::BTreeMap;
use std::{
    fs::{self, File},
    io::Write,
    path::Path,
    str::FromStr,
};

use anyhow::Context;
use chiptool::{
    generate::{self, CommonModule},
    ir, transform,
};
use proc_macro2::TokenStream;
use regex::Regex;

use crate::{rustfmt, AUTOGENERATED_TEXT};

pub fn generate(out_dir: &Path) -> anyhow::Result<BTreeMap<String, String>> {
    let mut block_map = BTreeMap::new();
    let common = out_dir.join("src/common.rs");

    // Must create `src` directory which common is eventually written to.
    let peripherals_dir = out_dir.join("src/_peripherals");
    fs::create_dir_all(&peripherals_dir).unwrap();

    // Common module
    fs::write(common, generate::COMMON_MODULE).unwrap();

    let options = generate::Options::new()
        .with_common_module(CommonModule::External(TokenStream::from_str("crate::common").unwrap()));

    for entry in fs::read_dir("build/data/registers")? {
        let entry = entry?;
        let f = entry.path();

        if !f.is_file() {
            continue;
        }

        let ctx = format!("{:?}", f.file_name());

        let mut ir: ir::IR = serde_json::from_str(&fs::read_to_string(&f).unwrap())
            .context(ctx.clone())
            .expect("Error reading registers");

        let block_name = ir.blocks.keys().next().unwrap().clone();
        let block_name_pascal = heck::AsPascalCase(&block_name).to_string();

        transform::expand_extends::ExpandExtends {}
            .run(&mut ir)
            .unwrap();

        transform::map_names(&mut ir, |k, s| match k {
            transform::NameKind::Block => *s = s.to_string(),
            transform::NameKind::Fieldset => *s = format!("regs::{}", s),
            transform::NameKind::Enum => *s = format!("vals::{}", s),
            _ => {}
        });

        for (_, fs) in ir.fieldsets.iter_mut() {
            let mut names = std::collections::HashSet::new();
            for f in fs.fields.iter_mut() {
                if names.contains(&f.name) {
                    let mut i = 0;
                    while names.contains(&format!("{}_{}", f.name, i)) {
                        i += 1;
                    }
                    f.name = format!("{}_{}", f.name, i);
                }
                names.insert(f.name.clone());
            }
        }

        chiptool::transform::sort::Sort {}.run(&mut ir).unwrap();
        chiptool::transform::sanitize::Sanitize {}.run(&mut ir).unwrap();

        let items = generate::render(&ir, &options)
            .context(ctx)
            .expect("Failed to generate code for peripheral");

        let name = f
            .file_name()
            .unwrap()
            .to_string_lossy()
            .replace(".json", "");
        
        block_map.insert(name.clone(), block_name_pascal);

        let path = peripherals_dir.join(format!("{}.rs", name));
        let mut file = File::create(&path).unwrap();

        writeln!(file, "{AUTOGENERATED_TEXT}").unwrap();
        writeln!(
            file,
            r"#![allow(clippy::missing_safety_doc)]
            #![allow(clippy::identity_op)]
            #![allow(clippy::unnecessary_cast)]
            #![allow(clippy::erasing_op)]
            #![allow(non_camel_case_types)]
            #![allow(non_snake_case)]
            #![allow(non_upper_case_globals)]"
        )
        .unwrap();

        let items = items.to_string().replace("] ", "]\n");
        let re = Regex::new("# *! *\\[.*\\]").unwrap();
        let items = re.replace_all(&items, "");
        writeln!(file, "{items}").unwrap();

        file.flush().unwrap();
        drop(file);

        rustfmt(path);
    }

    let mut mod_rs = File::create(peripherals_dir.join("mod.rs")).unwrap();
    writeln!(mod_rs, "{}", AUTOGENERATED_TEXT).unwrap();
    for entry in fs::read_dir(&peripherals_dir)? {
        let entry = entry?;
        let f = entry.path();
        if f.file_name().unwrap() == "mod.rs" {
            continue;
        }
        let name = f.file_stem().unwrap().to_string_lossy();
        writeln!(mod_rs, "pub mod {};", name).unwrap();
    }

    Ok(block_map)
}
